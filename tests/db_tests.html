<html>
<!--

-->
  <head>
    <link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.1/build/logger/assets/logger.css"> 
    <link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.1/build/yuitest/assets/testlogger.css"> 
    <script type="text/javascript" src="http://yui.yahooapis.com/2.8.1/build/yahoo-dom-event/yahoo-dom-event.js"></script> 
    <script type="text/javascript" src="http://yui.yahooapis.com/2.8.1/build/logger/logger-min.js"></script> 
    <script type="text/javascript" src="http://yui.yahooapis.com/2.8.1/build/yuitest/yuitest.js"></script>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.js"></script>
    <script type="text/javascript" src="js/json2.js"></script>
    <script type="text/javascript" src="js/data.js"></script>
  </head>
  <body>
  
  <script type="text/javascript">
  function assertJsonEqual(o1, o2) {
    Assert.areEqual(JSON.stringify(o1), JSON.stringify(o2));
  }

  function verifyQuery(testcase, query, expected, done) {
    var errormsg = 'unexpected result for ' + query;
    $().dbQuery(query,
     function(data) {
       testcase.offthread(function() {
        Assert.isUndefined(data.error, errormsg);
        Assert.isArray(data.results, errormsg);        
        assertJsonEqual(data.results, expected, errormsg);
      }, done);
    });
  }
   
    var Assert = YAHOO.util.Assert;
    var ArrayAssert = YAHOO.util.ArrayAssert;
    var logger = new YAHOO.tool.TestLogger(); // Log results to browser window
    var suite = new YAHOO.tool.TestSuite("data.js Test Suite");

    /** Asserts raise an error when they fail and asyncronous won't be running 
     *  within the TestRunner try/catch block. 
     *  offthread() runs code with assertions its own try/catch block and
     *  passes the exception to TestCase.resume() if it fails (which terminates the TestCase)
     *  
     *  @param done: If true, call resume() after executing
     */
    YAHOO.tool.TestCase.prototype.offthread = function(func, done) {
      try {
        func();
        if (done) {
            this.resumeOffthread();
        }        
      } catch (e) {
        if (window.console) console.log('offset thread error', e);
        this.offthreadError = e;
        this.resumeOffthread();
      }
    };

    YAHOO.tool.TestCase.prototype.resumeOffthread = function() {
      if (!YAHOO.tool.TestRunner._cur || this !== YAHOO.tool.TestRunner._cur.parent.testObject) {
        //this can happen if a Assert failed thus aborting the current testcase before this callback runs
        if (window.console) console.log('wait already ran', YAHOO.tool.TestRunner);
        return;
      } else {
        if (window.console) console.log('resumeOffthread called', YAHOO.tool.TestRunner);
      }        
      var testcase = this;      
      this.resume(function() {
         var offthreadError = testcase.offthreadError;
         if (window.console) console.log('resumeOffThread running', offthreadError);
         if (!YAHOO.lang.isUndefined(testcase.offthreadError)) 
            delete testcase.offthreadError;
         Assert.isUndefined(offthreadError);         
      });
    };

    YAHOO.tool.TestCase.prototype.checkResponse = function(data, shouldSucceed, failMsg, expectedErrorCode) {
      this.offthread(function() {
         if (shouldSucceed) {
           var msg = 'checkResponse: unexpected error ' + failMsg;
           if (window.console) {
              if (!YAHOO.lang.isUndefined(data.error)) 
                console.log(msg, data);
           }
           Assert.isUndefined(data.error, msg);
         } else {
           var msg = 'checkResponse: unexpected success ' + failMsg;
           if (window.console) {
             if (!YAHOO.lang.isObject(data.error)) 
                console.log(msg, data);
           }
           Assert.isObject(data.error, msg);
           if (expectedErrorCode) {
              Assert.areEqual(data.error.code, expectedErrorCode, 
                  'checkResponse: unexpected error code: ' + data.error.code);
           }
         }
      });
    };
        
    suite.add( new YAHOO.tool.TestCase({
        name: "data.js test1",
        
        testTest1 : function() {
          var testcase = this;
          
          var pjson1 = {
            id : '@1',
            prop1 : 'adds a value to prop1'
          };

          function verifyData(done) {
            verifyQuery(testcase, "{* where (id='1')}", [pjson1], done);
          }

          //javascript doesn't provide an easy way to do deep equality on objects, 
          //so instead we'll compare JSON strings of objects

          $().dbCreate(pjson1,
            function(data) {
              testcase.checkResponse(data, true, 'dbcreate');
              verifyData();
            }
          );

          /*
          $().dbAdd({
            id : '1',
            prop1 : 'adds a value to prop1'
          });

          $().dbSave({
            id : '1',
            prop1 : 'replaces current value of prop1'
          })

          //removes just this property
          //note: need the value to match 
          $().dbRemove({
            id : '1',
            prop1 : 'replaces current value of prop1'
          })

          //awkward, need to use save to remove the whole property
          $().dbReplace({ id : '1' }, function() { dbQuery() })
          */

          //test transaction rollback 
          $().dbBegin().dbAdd({id : '1',
              prop2 : 'another prop'
          }).dbQuery('{* where (id="1")}', function(response) {
            //error -32001 == client-side rollback       
            testcase.checkResponse(response, false, 'rollback', -32001); 
          }).dbRollback();

          //make sure old data is still there
          verifyData();

          //the dbCreate() should trigger an error on the server-side because the id 
          //is already defined that aborts the whole transaction 
          $().dbBegin().dbAdd({
              id : '1',
              prop2 : 'another prop'
            }, function(response){
               testcase.checkResponse(response, false, 'dbadd on failed txn');
            }).dbCreate({
                   id : '1',
                   prop3 : 'yet another prop'
            }, 
            function(response){
                testcase.checkResponse(response, false, 'dbcreate on failed txn');
            }).dbCommit(function(event, response){
              //console.log('dbcommit', arguments)
              testcase.checkResponse(response, false, 'dbcommit on failed txn');
              //make sure this failed transaction didn't alter the object
              verifyData(true);
          });

          this.wait(5000); //5 sec timeout
        },
    }));

    suite.add( new YAHOO.tool.TestCase({
        name: "data.js test2",
        
        testTest2 : function() {
          var testcase = this;
          //test dbdata custom event, should only be called once per transaction
          var customTrigger = 0
          var customTriggerFunc = function(event, data) { 
            customTrigger++;
            //console.log('customTrigger', customTrigger);
            testcase.offthread(function() {                
              Assert.areEqual(txnCallbacksCalled, 1);
            }, true); //this is the last test in this testcase
          }
          $().bind('dbdata-*', customTriggerFunc);

          var txnCallbacksCalled = 0;
          //make sure commit worked and dbQuery callback was called after dbCreate callback 
          $().dbBegin().dbReplace({ id : '1' }).dbQuery(
            "{* where (id='1')}",
             function(data) {
                txnCallbacksCalled++;
                //console.log('txnCallbacksCalled', txnCallbacksCalled);
                testcase.offthread(function() {
                  Assert.isUndefined(data.error);
                  Assert.isArray(data.results);
                  Assert.areEqual(data.results.length, 0);
                });
            }).dbCommit(function(event, response) {
              //we need resume() to be called by the last callback which should be this one
              //based on the order in which 'dbdata' handlers are bound
              //$().unbind('dbdata', customTriggerFunc);
              testcase.offthread(function() {                
                Assert.areEqual(txnCallbacksCalled, 1);
                Assert.areEqual(customTrigger, 0);
              });
          });
          
          this.wait(5000); //5 sec timeout
        }                        
    }));

    var TestRunner = YAHOO.tool.TestRunner;
    TestRunner.add( suite );
    function testRunComplete(data) {
      if (window.console) console.log('test run complete', data);
      var results = JSON.stringify(data.results);
      $.ajax({
        type: 'POST',
        url: '/testresult',
        data: results,
        processData: false, 
        contentType: 'application/json',
        dataType: "json"
      }); 
    }
    TestRunner.subscribe(TestRunner.COMPLETE_EVENT, testRunComplete);        
    TestRunner.run();
  </script> 

<div id='test1'></div>

  </body>
</html>
